var fs = require('fs');
var path = require('path');
var _ = require('lodash');

var Util = require('./util');
var Police = require('./police');

if (process.platform != 'win32'){
  var newline = "\n";
} else {
  var newline = "\r\n";
}

var CodeParse = {

  generateCommand: function(app) { //combine each tool's command to generate a pipeline
    //parse every tool
    var originalTool = app.state.currentTool;
    for (var i = 0; i <= app.state.lastId; i++){
      app.state.currentTool=i;
      if(!Police.checkToolDefinition(app)){
        return false;
      }
      this.parseToolCommand(app);
    }
    app.state.currentTool = originalTool;

    if (process.platform != 'win32'){
      app.state.command = "#!/usr/bin/bash";
      app.state.command += `${newline}#This code is generated by PipelineDog.${newline}`
      app.state.command += "cd "+app.state.workDir+newline;
      app.state.tools.map(function(level, i) {
        level.map(function(tool, i) {
          app.state.command += newline+tool.parsedCommand;
        }, this);
        app.state.command += `${newline}wait${newline}`;
      });
    } else {
      app.state.command = `REM This code is generated by PipelineDog.${newline}`;
      app.state.command += "CD "+app.state.workDir+newline;
      app.state.tools.map(function(level, i) {
        level.map(function(tool, i) {
          app.state.command += newline+tool.parsedCommand;
        }, this)
      });

    }

    return true;
  },

  parseToolCommand: function(app) { //replace placeholders and generate command for each tool

    //if these symbols are changed, the police class need to change accordingly.
    var scope = /[\{\}]/;
    var segment = '|';

    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);

    this.convertExpressions(app, scope, segment);

    if(!tool.looping) { //if the tool is not looping

      tool.parsedOptions = tool.codeobj.options.map(function(s, index) { //replace placeholders with the translated expressions
        var a = s.split(scope);
        for (var i=1; i < a.length-1; i+=2) {
          for (var j=0; j < tool.options.length; j++) {
            if(a[i] == tool.options[j]){
              a[i] = tool.expressions[j];
            }
          }
        }
        return a.join('');
      }, this);
      if (process.platform != 'win32'){
        tool.parsedCommand = tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&";
      } else {
        tool.parsedCommand = "START /wait " + tool.codeobj.invoke + " " + tool.parsedOptions.join(" ");
      }

    } else { //if the tool is looping

      tool.parsedCommand = "";

      var loopArray = [];
      for (var i=0; i < tool.options.length; i++) {
        if(tool.expressions[i]) loopArray.push(tool.expressions[i].split('^LOOP^'));
      }

      loopArray[0].map(function(fn, index, array) {
        tool.parsedOptions = tool.codeobj.options.map(function(s, innerindex) { //replace placeholders with the translated expressions
          var a = s.split(scope);
          for (var i=1; i < a.length-1; i+=2) {
            for (var j=0; j < tool.options.length; j++) {
              if(a[i] == tool.options[j]){
                a[i] = loopArray[j][index];
              }
            }
          }
          return a.join('');
        }, this);

        if(index!==array.length-1) {
          if (process.platform != 'win32'){
            tool.parsedCommand += tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&" + newline;
          } else {
            tool.parsedCommand += "START /wait " + tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + newline;

          }
        } else {
          if (process.platform != 'win32'){
            tool.parsedCommand += tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&";
          } else {
            tool.parsedCommand += "START /wait " + tool.codeobj.invoke + " " + tool.parsedOptions.join(" ");
          }
        }

      }, this);
    }

    //process looping for output files
    if(tool.expressions[tool.expressions.length-1]) {
      tool.expressions[tool.expressions.length-1] = tool.expressions[tool.expressions.length-1].map(function(of, i) {
        if(of.indexOf('^LOOP^') == -1) {
          return of;
        } else {
          return of.split('^LOOP^');
        }
      }, this)
      tool.output_files = _.flattenDeep(tool.expressions[tool.expressions.length-1]);
    }

  },

  convertExpressions: function(app, scope, segment) { //recognize LEASH expressions, also update output_files info
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    tool.expressions = [];
    tool.options = [];

    for (var key in tool.codeobj) {
      if(key.slice(-5) == '_expr') {
        tool.expressions.push(tool.codeobj[key]);
        tool.options.push(key.slice(0, -5).toUpperCase());
      }
    }
    tool.expressions.push(tool.codeobj.output_files);

    tool.expressions = tool.expressions.map(function(e, i, a) { //convert objects to standard LEASH
      if(typeof(e) == "object" && !Array.isArray(e)) { //Long(object) format
        var pseudoString = "{";
        if(e.file) pseudoString += `${e.file}F|`;
        if(e.line) pseudoString += `${e.line}L|`;
        if(e.base) pseudoString += `${e.base}B|`;
        if(e.extension) pseudoString += `${e.extension}E|`;
        if(e.arrangement) pseudoString += `${e.arrangement}A|`;
        if(pseudoString.slice(-1)=="|") pseudoString = pseudoString.slice(0,-1);
        pseudoString += "}";
        return i!=a.length-1?pseudoString:[pseudoString];
      }
      else { //Short(string or array) format
        return e;
      }
    }.bind(this));

    for (var j=0; j < tool.expressions.length-1; j++){ //translate each LEASH expressions
      if(tool.expressions[j] && typeof(tool.expressions[j]) != "object") {
        var a = tool.expressions[j].split(scope);
        for (var i=1; i < a.length-1; i+=2) {
          a[i] = this.parseLEASH(a[i], tool, segment);
        }
        tool.expressions[j] = a.join("");
      }
    }

    var outfilesArray = []; //process output_files array
    tool.expressions[tool.expressions.length-1].map(function(s) {
      var a = s.split(scope);
      if(a.length>=3){
        for (var i=1; i < a.length-1; i+=2) {
          outfilesArray.push(this.parseLEASH(a[i], tool, segment));
        }
      } else {
        outfilesArray.push(s);
      }
    }.bind(this));
    tool.expressions[tool.expressions.length-1] = _.flattenDeep(outfilesArray);

  },

  parseLEASH: function(expression, tool, segment) { //parse LEASH expression and process inputlists
    var inputlists = tool.codeobj.inputlists;
    var segs = [];
    var f = [];
    var l = [];
    var b = [];
    var e = [];
    var a = "";

    expression.split(segment).map(function(s, i) {
      if(s.slice(-1) == 'F') {
        segs[0] = s;
      }
      if(s.slice(-1) == 'L') {
        segs[1] = s;
      }
      if(s.slice(-1) == 'B') {
        segs[2] = s;
      }
      if(s.slice(-1) == 'E') {
        segs[3] = s;
      }
      if(s.slice(-1) == 'A') {
        segs[4] = s;
      }
    });
    if(!segs[0]) {
      segs[0] = "-F";
    }
    if(!segs[1]) {
      segs[1] = "-L";
    }
    if(!segs[2]) {
      segs[2] = "P-B";
    }
    if(!segs[3]) {
      segs[3] = "''E";
    }
    if(!segs[4]) {
      segs[4] = "'n'A";
    }

    segs.map(function(s, i) {
      switch(s.slice(-1)) {

        case 'F':
          var inputlistArray = this.parseRange(s.slice(0,-1), inputlists.length, inputlists);
          inputlistArray.map(function(fl, i) {
            var readdata = fs.readFileSync(inputlists[fl-1], 'utf8');
            if(readdata.slice(-1) == newline) {
              readdata = readdata.slice(0, -1);
            }
            readdata.split(newline).map(function(fline) {
              f.push(fline);
            }, this);
          }, this);
          break;

        case 'L':
          var lineArray = this.parseRange(s.slice(0,-1), f.length, f);
          lineArray.map(function(line, i) {
            l.push(f[line-1]);
          }, this);
          break;

        case 'B':
          b = l.map(function(filename, i) {
            var name = [];
            var baseArray = [];
            var dirname = path.dirname(filename);
            var basename = path.basename(filename);
            var bases = basename.split('.');

            if(s.slice(0, 1) == 'P'){
              baseArray = this.parseRange(s.slice(1,-1), bases.length, bases);
            } else {
              baseArray = this.parseRange(s.slice(0,-1), bases.length, bases);
            }
            baseArray.map(function(base, i) {
              name.push(bases[base-1]);
            }, this);
            return s.slice(0, 1) == 'P' ? path.join(dirname, name.join('.')) : name.join('.');
          }, this);
          break;

        case 'E':
          var r = '';
          e = b.map(function(filename, i) {
            var arr = s.slice(0,-1).split("'");
            for (var i=0; i < arr.length-1; i+=2) {
              var extensionString = arr[i+1];
              if(arr[i] == 'PRE') {
                filename = extensionString + filename;
              } else {
                filename = filename + extensionString;
              }
            }

            return filename;
          });
          break;

        case 'A':
          var arrangeString = s.replace(/['"]+/g, '').slice(0,-1);
          if(arrangeString == 'c') {
            a = e.join(',');
          } else if(arrangeString == 's') {
            a = e.join(' ');
          } else if(arrangeString == 'a') {
            a = e;
          } else if(arrangeString == 'n') {
            a = e.join('');
          } else if(arrangeString == 'l') {
            tool.looping = true;
            a = e.join('^LOOP^');
          } else {
            a = e.map(function(filename, i){
              return arrangeString+' '+filename;
            }).join(' ');
          }
          break;

      }
    }, this);
    return a;
  },

  parseRange: function(s, length, arr) {
    var r = [];
    if(s.indexOf('/') > -1) {
      //parse regex range
      var regex = new RegExp(s.slice(1,-1));
      arr.map(function(string, i) {
        if(string.search(regex) > -1) {
          r.push(i+1);
        };
      }, this);
      return r;
    } else {
      //parse numeric range
      var a = s.split(',');
      a.map(function(ss, i) {
        if(ss.indexOf('-') > -1) {
          var b = ss.split('-');
          if(b[0]=="" && b[1]==""){b[0] = 1; b[1] = length;}
          else if(b[1]==""){b[1] = length;}
          else if(b[0]==""){b[0] = 1;}
          else if(b.length>2 || Number(b[0]) > Number(b[1])){
            console.log("illegal range.")
            return;
          }
          for (var i = Number(b[0]); i <= Number(b[1]); i++) {
            r.push(i);
          }
        } else {
          r.push(Number(ss));
        }
      }, this);
      r.sort(function(x,y){return x-y});
      return _.uniq(r);
    }
  },

};

module.exports = CodeParse;
